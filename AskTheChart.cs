#region Using declarations
using NinjaTrader.Cbi;  
using NinjaTrader.Code;  
using NinjaTrader.Core.FloatingPoint;  
using NinjaTrader.Data;  
using NinjaTrader.Gui;  
using NinjaTrader.Gui.Chart;  
using NinjaTrader.Gui.SuperDom;  
using NinjaTrader.Gui.Tools;  
using NinjaTrader.NinjaScript;  
using NinjaTrader.NinjaScript.DrawingTools;  
using System;  
using System.Collections;  
using System.Collections.Generic;  
using System.ComponentModel;  
using System.ComponentModel.DataAnnotations;  
using System.IO;  
using System.Linq;  
using System.Net.Http;  
using System.Net.Http.Headers;  
using System.Reflection;  
using System.Security.Cryptography;  
using System.Text;  
using System.Threading;  
using System.Threading.Tasks;  
using System.Web.Script.Serialization;  
using System.Windows;  
using System.Windows.Controls;  
using System.Windows.Input;  
using System.Windows.Markup;  
using System.Windows.Media;  
using System.Windows.Threading;  
using System.Xml.Serialization;  
#endregion

#region Updates
// NT8 AskTheChart by pixel @ nexusfi.com, Version 0.1.0, released 10/19/2023 NT8 8.1.1.7 64-bit
// 10/22/2023 v0.1.01 - Fix: model variable missing
// 10/22/2023 v0.1.02 - Removed duplicate declarations
// 11/14/2023 v0.1.03 - Removed delay for faster function calling
// 11/14/2023 v0.1.04 - Fix: error when using dynamic type
#endregion

#region Acknowledgments
/*  
- ChatGPT "Chat Generative Pre-trained Transformer"
- Azure OpenAI Service
- marcel-kwiatkowsk/functional-gpt
- Mak Ziga/flowgpt
*/
#endregion 

#region @TODO
/*  
- Chatbox font size option
- Optimize highlight region for prompts.
- Central logging
- Cancel API request on resets or exits
- Markdown formatting
- Add more drawing tools
- Add more agent examples
- Color options for drawing tool functions
*/
#endregion

#region Disclaimer
/*  
Disclaimer:  
The AskTheChart indicator for NinjaTrader 8 is designed to provide   
chart-based information using chatbot technology. However, trading   
involves substantial risk of loss and is not suitable for everyone.  
  
The AskTheChart indicator does not guarantee profits or protect   
against losses. It's an informational tool and does not offer   
personalized trading advice. Users are responsible for their   
trading decisions, including understanding the potential risks involved.  
  
The responses generated by AI may not accurately predict market   
conditions, which are influenced by many factors outside the   
AI's training data and algorithms.  
  
Investors should only risk capital they are prepared to lose.   
Always consider personal financial circumstances, experience,   
risk tolerance, and investment objectives before trading.   
It's recommended users seek advice from a certified financial advisor   
or conduct independent research.  
  
By using the AskTheChart indicator, users agree to take full   
responsibility for their trading decisions and acknowledge   
that they understand the risks involved.  
*/  

#endregion

namespace NinjaTrader.NinjaScript.Indicators.Protechy
{
    #region Indicator

    public class AskTheChart : Indicator
    {
	    private string _apiKey;  
	    private bool _apiKeyChanged = false;  
	    private string _savedApiKey;  
	    private string apiKeyFilePath;  
	    private System.Windows.Controls.Button askTheChartButton = null;  
	    private Chart chartWindow;  
	    private ChatWindow chatWindow = null;  
	    private bool IsAskTheChartBtnAdded;  
	    private string machineId;  
	    private const string MaskedApiKey = "****************";  
	    private static int prevIndicatorCount = 0;  
	    private string uniqueEnv;

        protected override void OnStateChange()
        {
            if (State == State.SetDefaults)
            {
                Description = @"AI-powered indicator that showcases the use of a large language model to enhance trading strategies and analysis using agents";
                Name = "AskTheChart";
                Calculate = Calculate.OnBarClose;
                IsOverlay = true;
                DisplayInDataBox = false;
                DrawOnPricePanel = true;
                DrawHorizontalGridLines = true;
                DrawVerticalGridLines = true;
                PaintPriceMarkers = true;
                ScaleJustification = NinjaTrader.Gui.Chart.ScaleJustification.Right;
                IsSuspendedWhileInactive = true;
                Url = "";
                MaxBars = 150;
                ApiKey = "";
				Model = "gpt-4";

                if (string.IsNullOrEmpty(UniqueEnv))
                {
                    UniqueEnv = Guid.NewGuid().ToString();
                }

                apiKeyFilePath = NinjaTrader.Core.Globals.UserDataDir + Name + "Env_" + UniqueEnv + ".txt";
            }
            else if (State == State.Configure)
            {
                if (!string.IsNullOrEmpty(UniqueEnv))
                {
                    apiKeyFilePath = NinjaTrader.Core.Globals.UserDataDir + Name + "Env_" + uniqueEnv + ".txt";
                }

                if (ApiKey != MaskedApiKey && !string.IsNullOrEmpty(ApiKey))
                {
                    SaveEncryptedAPIKey(ApiKey, apiKeyFilePath);
                    _savedApiKey = ApiKey;
                    _apiKeyChanged = false;
                }

                if (ApiKey == MaskedApiKey)
                {
                    Output.Process("Load API Key", PrintTo.OutputTab1);
                    _savedApiKey = LoadDecryptedAPIKey(apiKeyFilePath);
                }
            }
            else if (State == State.DataLoaded)
            {
                if (!IsAskTheChartBtnAdded) AddBtnToolbar();
                ChartDrawer.Initialize(this);
            }
            else if (State == State.Terminated)
            {
                CleanUp();
            }
        }

        protected override void OnBarUpdate()
        {
        }

        #region API key

        private string GetMachineId()
        {
            return NinjaTrader.Cbi.License.MachineId;
        }

        public string GetMacAddress()
        {
            foreach (System.Net.NetworkInformation.NetworkInterface nic in System.Net.NetworkInformation.NetworkInterface.GetAllNetworkInterfaces())
            {
                if (nic.OperationalStatus == System.Net.NetworkInformation.OperationalStatus.Up)
                {
                    return nic.GetPhysicalAddress().ToString();
                }
            }
            return String.Empty;
        }

        private void SaveEncryptedAPIKey(string apiKey, string filePath)
        {
            var bytesToBeEncrypted = Encoding.UTF8.GetBytes(apiKey);
            var passwordBytes = Encoding.UTF8.GetBytes(GetMachineId() + GetMacAddress());

            passwordBytes = SHA256.Create().ComputeHash(passwordBytes);

            var bytesEncrypted = AES_Encrypt(bytesToBeEncrypted, passwordBytes);

            File.WriteAllBytes(filePath, bytesEncrypted);
        }

        private string LoadDecryptedAPIKey(string filePath)
        {
            var passwordBytes = Encoding.UTF8.GetBytes(GetMachineId() + GetMacAddress());
            passwordBytes = SHA256.Create().ComputeHash(passwordBytes);

            var bytesToBeDecrypted = File.ReadAllBytes(filePath);
            var bytesDecrypted = AES_Decrypt(bytesToBeDecrypted, passwordBytes);

            return Encoding.UTF8.GetString(bytesDecrypted);
        }

        private byte[] AES_Decrypt(byte[] bytesToBeEncrypted, byte[] passwordBytes)
        {
            byte[] decryptedBytes = null;

            using (MemoryStream ms = new MemoryStream())
            {
                using (Aes aes = Aes.Create())
                {
                    aes.KeySize = 256;
                    aes.BlockSize = 128;

                    var key = new Rfc2898DeriveBytes(passwordBytes, new byte[] { 1, 2, 3, 4, 5, 6, 7, 8 }, 1000);
                    aes.Key = key.GetBytes(aes.KeySize / 8);
                    aes.IV = key.GetBytes(aes.BlockSize / 8);

                    aes.Mode = CipherMode.CBC;

                    using (var cs = new CryptoStream(ms, aes.CreateDecryptor(), CryptoStreamMode.Write))
                    {
                        cs.Write(bytesToBeEncrypted, 0, bytesToBeEncrypted.Length);
                        cs.Close();
                    }

                    decryptedBytes = ms.ToArray();
                }
            }

            return decryptedBytes;
        }

        private byte[] AES_Encrypt(byte[] bytesToBeEncrypted, byte[] passwordBytes)
        {
            byte[] encryptedBytes = null;

            using (MemoryStream ms = new MemoryStream())
            {
                using (Aes aes = Aes.Create())
                {
                    aes.KeySize = 256;
                    aes.BlockSize = 128;

                    var key = new Rfc2898DeriveBytes(passwordBytes, new byte[] { 1, 2, 3, 4, 5, 6, 7, 8 }, 1000);
                    aes.Key = key.GetBytes(aes.KeySize / 8);
                    aes.IV = key.GetBytes(aes.BlockSize / 8);

                    aes.Mode = CipherMode.CBC;

                    using (var cs = new CryptoStream(ms, aes.CreateEncryptor(), CryptoStreamMode.Write))
                    {
                        cs.Write(bytesToBeEncrypted, 0, bytesToBeEncrypted.Length);
                        cs.Close();
                    }

                    encryptedBytes = ms.ToArray();
                }
            }

            return encryptedBytes;
        }
        #endregion

        #region Toolbar button

        private void AddBtnToolbar()
        {
            ChartControl.Dispatcher.InvokeAsync((Action)(() =>
            {
                if (this.ChartControl.Parent == null)
                {
                    this.Dispatcher.BeginInvoke((Action)(() => AddBtnToolbar()));
                    return;
                }

                chartWindow = Window.GetWindow(this.ChartControl.Parent) as Chart;

                if (chartWindow == null)
                {
                    return;
                }

                Style s = new Style();
                s.TargetType = typeof(System.Windows.Controls.Button);
                s.Setters.Add(new Setter(System.Windows.Controls.Button.FontSizeProperty, 14.0));
                s.Setters.Add(new Setter(System.Windows.Controls.Button.ForegroundProperty, Brushes.White));
                s.Setters.Add(new Setter(System.Windows.Controls.Button.FontFamilyProperty, new FontFamily("Arial")));
                askTheChartButton = new System.Windows.Controls.Button();
                askTheChartButton.Style = s;
                askTheChartButton.Content = "🤖";  // Ask About the Chart
                askTheChartButton.IsEnabled = true;
                askTheChartButton.HorizontalAlignment = HorizontalAlignment.Left;
                askTheChartButton.Click += AskChartButtonClick;
                chartWindow.MainMenu.Add(askTheChartButton);
                askTheChartButton.Visibility = Visibility.Collapsed;

                foreach (TabItem tab in this.chartWindow.MainTabControl.Items)
                {
                    if ((tab.Content as ChartTab).ChartControl == this.ChartControl

                         && tab == this.chartWindow.MainTabControl.SelectedItem)
                    {
                        askTheChartButton.Visibility = Visibility.Visible;
                    }
                }
                IsAskTheChartBtnAdded = true;

                chartWindow.Closed += ChartWindow_Closed;
            }));
        }

        private void ChartWindow_Closed(object sender, EventArgs e)
        {
            if (chatWindow != null)
            {
                chatWindow.Close();
                chatWindow = null;
            }
            if (File.Exists(apiKeyFilePath))
            {
                File.Delete(apiKeyFilePath);
            }
        }

        protected async void AskChartButtonClick(object sender, RoutedEventArgs e)
        {
            if (string.IsNullOrWhiteSpace(this.ApiKey) || string.IsNullOrWhiteSpace(this.Url))
            {
                MessageBox.Show("OpenAI/Azure API Key or URL cannot be blank.  Please check your indicator settings", "Error", MessageBoxButton.OK, MessageBoxImage.Error);
                return;
            }
            if (!IsValidUrl(this.Url))
            {
                MessageBox.Show("The URL is not valid.  Please check your indicator settings", "Error", MessageBoxButton.OK, MessageBoxImage.Error);
                return;
            }
            if (chatWindow == null || !chatWindow.IsLoaded)
            {
                chatWindow = new ChatWindow(_savedApiKey, this.Url, this.MaxBars, this.Model);
            }

            if (chatWindow != null)
            {
                if (chatWindow.IsVisible)
                {
                    chatWindow.Focus();
                }
                else
                {
                    chatWindow.Show();
                }
            }
        }

        private bool IsValidUrl(string url)
        {
            Uri uriResult;
            bool result = Uri.TryCreate(url, UriKind.Absolute, out uriResult)
                && (uriResult.Scheme == Uri.UriSchemeHttp || uriResult.Scheme == Uri.UriSchemeHttps);
            return result;
        }

        private void CleanUp()
        {
            if (chartWindow != null)
            {
                ChartControl.Dispatcher.InvokeAsync((Action)(() =>
                {
                    if (askTheChartButton != null)
                    {
                        chartWindow.MainMenu.Remove(askTheChartButton);

                    }
                    var currentIndicatorCount = this.ChartControl.ChartObjects.Count;
                    if (currentIndicatorCount < prevIndicatorCount || ChartControl == null)
                    {
                        if (File.Exists(apiKeyFilePath))
                        {
                            File.Delete(apiKeyFilePath);
                        }
                    }
                    prevIndicatorCount = currentIndicatorCount;
                    var chatWindow = chartWindow.FindName("chatWindow") as ChatWindow;
                    if (chatWindow != null)
                    {
                        chatWindow.ClearChatWindow();
                    }
                }));
            }
        }
        #endregion

        #region Properties

		
		[NinjaScriptProperty]
        [Display(Name = "URL", Description = "URL to fetch data from", Order = 1, GroupName = "0) Indicator settings")]
        public string Url { get; set; }
		
        [NinjaScriptProperty]
        [Display(Name = "API Key", Description = "Your OpenAI/Azure API Key", Order = 2, GroupName = "0) Indicator settings")]
        public string ApiKey
        {
            get
            {
                if (!_apiKeyChanged)
                {
                    return MaskedApiKey;
                }
                return _apiKey;
            }
            set
            {
                if (_apiKey != value)
                {
                    _apiKeyChanged = true;
                }
                _apiKey = value;
            }
        }
		
        [NinjaScriptProperty]
        [Display(Name = "Model", Description = "ChatGPT model", Order = 3, GroupName = "0) Indicator settings")]
        public string Model { get; set; }

        [NinjaScriptProperty]
        [Range(1, int.MaxValue)]
        [Display(Name = "Max Bars", Description = "Max number of bars allowed for chatgpt", Order = 4, GroupName = "0) Indicator settings")]
        public int MaxBars { get; set; }

        [NinjaScriptProperty]
        [Display(ResourceType = typeof(Custom.Resource), Name = "Unique Env ID", Description = "Unique Identifier for the env file", GroupName = "1) Environment", Order = 0)]
        //public string UniqueEnv { get; set; } 
        public string UniqueEnv
        {
            get
            {
                return uniqueEnv;
            }
            set
            {
                uniqueEnv = value;
            }
        }
        #endregion
    }
    #endregion

    #region Chat Window

    public class ChatWindow : Window
    {
        public string ApiKey { get; set; }
        public string Url { get; set; }
		public string Model { get; set; }
        public int MaxBars { get; set; }
		
        private TextBox questionTextBox;
        private Button submitButton;
        private ScrollViewer chatScrollViewer;
        private StackPanel sidebarButtons;
        private static ChatWindow activeChatWindow;
        private ProgressBar loadingAnimation;
        private List<string> chatHistory = new List<string>();

        private StringBuilder currentResponse = new StringBuilder();
        private StringBuilder fullChatbotResponse = new StringBuilder();

        public StackPanel ChatContainer { get; set; }
        public TextBlock CurrentResponseTextBlock { get; set; }

        private DispatcherTimer updateTimer;
        private Dictionary<string, IAgent> agents = new Dictionary<string, IAgent>();
        private IAgent currentAgent;

        public ChatWindow(string apiKey, string url, int maxBars, string model)
        {
            Title = "Ask the Chart";
            Width = 550;
            Height = 600;
            MinWidth = 400;
            MinHeight = 400;
            ResizeMode = ResizeMode.CanResizeWithGrip;
            WindowStyle = WindowStyle.None;
            Background = new SolidColorBrush(Color.FromRgb(25, 25, 25));

            ApiKey = apiKey;
            Url = url;
            MaxBars = maxBars;
			Model = model;

            agents.Add("Chart Drawer Agent", new ChartDrawerAgent(this));
            agents.Add("Market Condition(1hr)", new MarketConditionAgent(this));
            agents.Add("Jesse Livermore", new JesseLivermore(this));

            SizeChanged += PromptWindow_SizeChanged;

            string customStyleXaml = @"  
			<Style xmlns=""http://schemas.microsoft.com/winfx/2006/xaml/presentation""  
			    xmlns:x=""http://schemas.microsoft.com/winfx/2006/xaml""  
			    TargetType=""Window""  
			    x:Key=""CustomWindowStyle"">  
			  
			    <Setter Property=""WindowChrome.WindowChrome"">  
			        <Setter.Value>  
			            <WindowChrome CaptionHeight=""30""  
			                ResizeBorderThickness=""6""  
			                CornerRadius=""0""  
			                GlassFrameThickness=""0""  
			                UseAeroCaptionButtons=""True"" />  
			        </Setter.Value>  
			    </Setter>  
			  
			    <Setter Property=""Template"">  
			        <Setter.Value>  
			            <ControlTemplate TargetType=""Window"">  
			                <DockPanel LastChildFill=""True"">  
			                    <!-- Sidebar -->  
			                    <Grid DockPanel.Dock=""Left"" Background=""#FF1F1F1F"" Width=""180"">  
									<TextBlock x:Name=""sidebarTitle""  
									               Text=""Ask the Chart""   
									               HorizontalAlignment=""Left""   
									               VerticalAlignment=""Top""   
									               Margin=""10""   
									               Foreground=""White"" />  
									<Grid x:Name=""sidebarGrid"" Margin=""0,40,0,0"">  
									    <Grid.RowDefinitions>  
									        <RowDefinition Height=""*""/>  
									        <RowDefinition Height=""Auto""/>  
									    </Grid.RowDefinitions>  
									    <StackPanel x:Name=""sidebarButtons"" Grid.Row=""0""></StackPanel>  
									    <Button x:Name=""clearChatButton"" Width=""150"" Height=""30"" Content=""Reset Agent"" FontSize=""13"" Grid.Row=""1"" Margin=""0,0,0,25""/>
									</Grid>  
			                    </Grid>  
			                    <!-- Existing Content -->  
			                    <Grid>  
			                        <Border Background=""{TemplateBinding Background}""  
			                            BorderBrush=""{TemplateBinding BorderBrush}""  
			                            BorderThickness=""{TemplateBinding BorderThickness}"">  
			                            <AdornerDecorator>  
			                                <ContentPresenter />  
			                            </AdornerDecorator>  
			                        </Border>  
			                        <Border Background=""#FF1F1F1F"" Height=""30"" VerticalAlignment=""Top"">  
			                            <Grid>  
			                                <TextBlock Text=""{TemplateBinding Title}"" Margin=""10,0,0,0"" VerticalAlignment=""Center"" Foreground=""White"" />  
			                                <ProgressBar x:Name=""loadingAnimation"" IsIndeterminate=""True"" Visibility=""Collapsed""  
			                                    HorizontalAlignment=""Center"" VerticalAlignment=""Center""  
			                                    Width=""100"" Height=""5"" Grid.Column=""0"" Foreground=""#ff4200"" />  
											<UniformGrid Rows=""1"" Columns=""3"" HorizontalAlignment=""Right"" Width=""90"">
												<Button x:Name=""minimizeButton"" Width=""30"" Height=""25"">
													<Button.Template>
														<ControlTemplate TargetType=""Button"">
															<ContentPresenter/>
														</ControlTemplate>
													</Button.Template>
													<Button.Content>
														<TextBlock Text=""_"" Foreground=""White"" FontSize=""16""/>
													</Button.Content>
												</Button>
												<Button x:Name=""maximizeButton"" Width=""30"" Height=""25"" Margin=""0,0,0,0"">
													<Button.Template>
														<ControlTemplate TargetType=""Button"">
															<ContentPresenter/>
														</ControlTemplate>
													</Button.Template>
													<Button.Content>
														<TextBlock Text=""□"" Foreground=""White"" FontSize=""20""/>
													</Button.Content>
												</Button>
												<Button x:Name=""closeButton"" Width=""30"" Height=""25"" Margin=""0,8,0,0"">
													<Button.Template>
														<ControlTemplate TargetType=""Button"">
															<ContentPresenter/>
														</ControlTemplate>
													</Button.Template>
													<Button.Content>
														<TextBlock Text=""X"" Foreground=""White"" FontSize=""14""/>
													</Button.Content>
												</Button>
											</UniformGrid>
			                            </Grid>  
			                        </Border>  
									<Grid Margin=""0,32,0,0"">
										<Grid.RowDefinitions>
											<RowDefinition Height=""*""/>
											<RowDefinition Height=""Auto""/>
										</Grid.RowDefinitions>
										<ScrollViewer x:Name=""chatScrollViewer"" Grid.Row=""0"" VerticalScrollBarVisibility=""Auto"">
											<StackPanel x:Name=""chatContainer"" Margin=""0,30,0,0"">
											</StackPanel>
										</ScrollViewer>
										<GridSplitter Grid.Row=""1"" Height=""Auto"" HorizontalAlignment=""Stretch"" VerticalAlignment=""Top""/>
										<Border Grid.Row=""1"" Background=""#FF3D3D3D"" Margin=""15,15,15,15"" CornerRadius=""25"" x:Name=""borderRow"">
											<Grid>
												<Grid.ColumnDefinitions>
													<ColumnDefinition Width=""*""/>
													<ColumnDefinition Width=""40""/>
												</Grid.ColumnDefinitions>
												<TextBox x:Name=""questionTextBox"" Background=""Transparent"" Foreground=""White"" Margin=""10,10,10,10"" TextWrapping=""Wrap"" BorderThickness=""0"" Grid.Column=""0""
														VerticalContentAlignment=""Center"" FontSize=""16"" />
												<Button x:Name=""submitButton"" Height=""50"" HorizontalAlignment=""Right"" Grid.Column=""1"" Margin=""0,0,0,0"">
												<Button.Template>
												<ControlTemplate TargetType=""Button"">
													<Path Data=""M0,0 L6,3 L0,6 L0,0"" Fill=""White"" Stretch=""Uniform"" />
												</ControlTemplate>
												</Button.Template>
												</Button>
											</Grid>
										</Border>
									</Grid> 
			                    </Grid>  
			                </DockPanel>  
			            </ControlTemplate>  
			        </Setter.Value>  
			    </Setter>  
			</Style>  
			";

            Style customStyle = (Style)XamlReader.Parse(customStyleXaml);
            Resources.Add("CustomWindowStyle", customStyle);

            Style = (Style)Resources["CustomWindowStyle"];

            ApplyTemplate();

            questionTextBox = (TextBox)Template.FindName("questionTextBox", this);
            submitButton = (Button)Template.FindName("submitButton", this);
            chatScrollViewer = (ScrollViewer)Template.FindName("chatScrollViewer", this);
            ChatContainer = (StackPanel)Template.FindName("chatContainer", this);

            loadingAnimation = (ProgressBar)Template.FindName("loadingAnimation", this);
            loadingAnimation.Visibility = Visibility.Collapsed;

            submitButton.Click += SubmitButton_Click;
            submitButton.MouseEnter += SubmitButton_MouseEnter;
            submitButton.MouseLeave += SubmitButton_MouseLeave;

            Button closeButton = (Button)Template.FindName("closeButton", this);

            closeButton.Click += CloseButton_Click;

            Button maximizeButton = (Button)Template.FindName("maximizeButton", this);
            Button minimizeButton = (Button)Template.FindName("minimizeButton", this);

            System.Windows.Shell.WindowChrome.SetIsHitTestVisibleInChrome(closeButton, true);
            System.Windows.Shell.WindowChrome.SetIsHitTestVisibleInChrome(maximizeButton, true);
            System.Windows.Shell.WindowChrome.SetIsHitTestVisibleInChrome(minimizeButton, true);

            maximizeButton.Click += MaximizeButton_Click;
            minimizeButton.Click += MinimizeButton_Click;

            questionTextBox.PreviewKeyDown += QuestionTextBox_PreviewKeyDown;

            Border borderRow = (Border)Template.FindName("borderRow", this);

            borderRow.MouseEnter += BorderRow_MouseEnter;
            borderRow.MouseLeave += BorderRow_MouseLeave;
            borderRow.MouseLeftButtonDown += BorderRow_MouseLeftButtonDown;
            questionTextBox.PreviewKeyDown += QuestionTextBox_PreviewKeyDown;

            Loaded += PromptWindow_Loaded;
            Closed += PromptWindow_Closed;

            Button clearChatButton = (Button)Template.FindName("clearChatButton", this);
            clearChatButton.Click += ClearChatButton_Click;

            StackPanel sidebarButtons = (StackPanel)Template.FindName("sidebarButtons", this);

            foreach (var agent in agents.Values)
            {
                Button agentButton = new Button
                {
                    Content = agent.Name,
                    HorizontalAlignment = HorizontalAlignment.Stretch,
                    Margin = new Thickness(10, 5, 10, 5),
                    FontSize = 13.0,
                    Padding = new Thickness(10, 5, 10, 5),
                    BorderThickness = new Thickness(0)
                };

                agentButton.Click += AgentButton_Click;
                agentButton.MouseEnter += (sender, e) => { Mouse.OverrideCursor = Cursors.Hand; };
                agentButton.MouseLeave += (sender, e) => { Mouse.OverrideCursor = null; };

                sidebarButtons.Children.Add(agentButton);
            }
        }

        public void ClearChatWindow()
        {
            this.Dispatcher.Invoke(() =>
            {
                this.chatHistory.Clear();
                this.ChatContainer.Children.Clear();
            });
        }

        private void PromptWindow_SizeChanged(object sender, SizeChangedEventArgs e)
        {
            double newMaxWidth = e.NewSize.Width - 240;
            foreach (UIElement element in ChatContainer.Children)
            {
                if (element is StackPanel)
                {
                    StackPanel responsePanel = element as StackPanel;
                    foreach (UIElement child in responsePanel.Children)
                    {
                        if (child is Grid)
                        {
                            Grid responseGrid = child as Grid;
                            foreach (UIElement childElement in responseGrid.Children)
                            {
                                if (childElement is TextBlock)
                                {
                                    TextBlock responseTextBox = childElement as TextBlock;
                                    TextBlock messageTextBox = childElement as TextBlock;
                                    responseTextBox.MaxWidth = newMaxWidth;
                                    messageTextBox.MaxWidth = newMaxWidth;
                                }
                            }
                        }
                    }
                }
            }
        }

        private async void PromptWindow_Loaded(object sender, RoutedEventArgs e)
        {
            if (activeChatWindow != null && !ReferenceEquals(this, activeChatWindow))
            {
                activeChatWindow.Focus();
                Close();
            }
            else
            {
                activeChatWindow = this;
                questionTextBox.Focus();
                sidebarButtons = (StackPanel)Template.FindName("sidebarButtons", this);
                if (sidebarButtons.Children.Count > 0)
                {
                    Button firstButton = sidebarButtons.Children[0] as Button;
                    if (firstButton != null)
                    {
                        AgentButton_Click(firstButton, new RoutedEventArgs(Button.ClickEvent));
                    }
                }
            }
        }

        private async Task InitializeAgentAsync()
        {
            if (currentAgent != null && currentAgent.ConversationHistory.Count == 0 && !string.IsNullOrEmpty(currentAgent.WelcomeMessage))
            {
                ChatboxResponse();
                loadingAnimation.Visibility = Visibility.Visible;

                string welcomeMessage = currentAgent.WelcomeMessage;
                currentAgent.ChatContext.Conversation.FromAssistant(welcomeMessage);

                if (sidebarButtons != null)
                {
                    foreach (Button button in sidebarButtons.Children.OfType<Button>())
                    {
                        button.IsEnabled = false;
                    }
                }
                string response = await currentAgent.ChatContext.ChatGPT.CompleteAsync(currentAgent.ChatContext.Conversation);
                currentAgent.ConversationHistory.Add(new MessageInfo { Sender = "Bot", Message = response });
                ProcessChatbotResponseLine(response);
                ScrollToBottom();
                loadingAnimation.Visibility = Visibility.Collapsed;
                questionTextBox.Clear();
                fullChatbotResponse.Clear();

                if (sidebarButtons != null)
                {
                    foreach (Button button in sidebarButtons.Children.OfType<Button>())
                    {
                        button.IsEnabled = true;
                    }
                }
            }
        }

        private void PromptWindow_Closed(object sender, EventArgs e)
        {
            if (ReferenceEquals(this, activeChatWindow) && activeChatWindow != null && activeChatWindow.IsLoaded)
            {
                activeChatWindow = null;
            }
        }

        private async void SubmitButton_Click(object sender, RoutedEventArgs e)
        {
            await SubmitQuestion();
        }

        private void CloseButton_Click(object sender, RoutedEventArgs e)
        {
            if (activeChatWindow != null && activeChatWindow.IsLoaded)
            {
                activeChatWindow = null;
                Close();
            }
        }

        private void BorderRow_MouseEnter(object sender, MouseEventArgs e)
        {
            Mouse.OverrideCursor = Cursors.IBeam;
        }

        private void BorderRow_MouseLeave(object sender, MouseEventArgs e)
        {
            Mouse.OverrideCursor = null;
        }

        private void BorderRow_MouseLeftButtonDown(object sender, MouseButtonEventArgs e)
        {
            questionTextBox.Focus();
        }

        private void SubmitButton_MouseEnter(object sender, MouseEventArgs e)
        {
            Mouse.OverrideCursor = Cursors.Hand;
        }

        private void SubmitButton_MouseLeave(object sender, MouseEventArgs e)
        {
            Mouse.OverrideCursor = null;
        }

        private void MinimizeButton_Click(object sender, RoutedEventArgs e)
        {
            WindowState = WindowState.Minimized;
        }

        private void MaximizeButton_Click(object sender, RoutedEventArgs e)
        {
            if (WindowState == WindowState.Maximized)
            {
                WindowState = WindowState.Normal;
            }
            else
            {
                var workingArea = SystemParameters.WorkArea;
                MaxHeight = workingArea.Height;
                MaxWidth = workingArea.Width;

                WindowState = WindowState.Maximized;
            }
        }

        private void AgentButton_Click(object sender, RoutedEventArgs e)
        {
            Button clickedButton = sender as Button;
            string agentName = clickedButton.Content.ToString();

            if (agents.ContainsKey(agentName))
            {
                currentAgent = agents[agentName];
                Title = currentAgent.Name;
                foreach (Button button in sidebarButtons.Children.OfType<Button>())
                {
                    button.Background = new SolidColorBrush(Color.FromRgb(40, 40, 40));
                }
                clickedButton.Background = new SolidColorBrush(Color.FromRgb(60, 60, 60));

                UpdateConversation(currentAgent);
                ScrollToBottom();
                questionTextBox.Focus();

                if (currentAgent.ConversationHistory.Count == 0)
                {
                    InitializeAgentAsync();
                }
            }
        }

        public void UpdateConversation(IAgent agent)
        {
            ChatContainer.Children.Clear();

            foreach (var messageInfo in agent.ConversationHistory)
            {
                if (messageInfo.Sender == "User")
                {
                    AddUserMessage(messageInfo.Message);
                }
                else if (messageInfo.Sender == "Bot")
                {
                    ProcessChatbotResponseLine(messageInfo.Message);
                }
            }
        }

        private void AddUserMessage(string message)
        {
            TextBlock messageTextBox = new TextBlock
            {
                Text = message,
                Background = new SolidColorBrush(Color.FromRgb(40, 40, 40)),
                Foreground = new SolidColorBrush(Color.FromRgb(216, 216, 221)),
                TextWrapping = TextWrapping.Wrap,
                Margin = new Thickness(10, 5, 10, 11),
                Padding = new Thickness(10),
                MaxWidth = chatScrollViewer.ViewportWidth - 60,
                MinWidth = 50,
                HorizontalAlignment = HorizontalAlignment.Right,
                VerticalAlignment = VerticalAlignment.Top,
                TextAlignment = TextAlignment.Right,
                FontSize = 16,
                LineHeight = 24
            };
            ChatContainer.Children.Add(messageTextBox);
        }

        public void ProcessUserMessage(string message)
        {
            TextBlock responseTextBox = new TextBlock
            {
                Text = "🤖 " + message,
                Background = new SolidColorBrush(Color.FromRgb(40, 40, 40)),
                Foreground = new SolidColorBrush(Color.FromRgb(216, 216, 221)),
                TextWrapping = TextWrapping.Wrap,
                Margin = new Thickness(10, 5, 10, 11),
                Padding = new Thickness(10),
                MaxWidth = chatScrollViewer.ViewportWidth - 60,
                MinWidth = 50,
                HorizontalAlignment = HorizontalAlignment.Left,
                VerticalAlignment = VerticalAlignment.Top,
                TextAlignment = TextAlignment.Left,
                FontSize = 16,
                LineHeight = 24
            };

            Border clipboardButton = new Border
            {
                Width = 24,
                Height = 24,
                Background = new SolidColorBrush(Color.FromRgb(40, 40, 40)),
                BorderThickness = new Thickness(1),
                BorderBrush = new SolidColorBrush(Color.FromRgb(216, 216, 221)),
                Padding = new Thickness(4),
                CornerRadius = new CornerRadius(3),
                Margin = new Thickness(0, 8, 0, 0),
                HorizontalAlignment = HorizontalAlignment.Right,
                VerticalAlignment = VerticalAlignment.Top,
            };

            TextBlock clipboardText = new TextBlock
            {
                Text = "📋",
                FontSize = 12,
                Foreground = new SolidColorBrush(Color.FromRgb(216, 216, 221)),
                HorizontalAlignment = HorizontalAlignment.Center,
                VerticalAlignment = VerticalAlignment.Center,
            };
            clipboardButton.Child = clipboardText;

            ToolTipService.SetToolTip(clipboardButton, "Copy to Clipboard");

            clipboardButton.MouseDown += (sender, e) =>
            {
                Clipboard.SetText(message);
                clipboardText.Text = "✔️";
                Task.Delay(1000).ContinueWith(_ =>
                {
                    Dispatcher.Invoke(() =>
                    {
                        clipboardText.Text = "📋";
                    });
                });
            };

            clipboardButton.MouseEnter += (sender, e) =>
            {
                Mouse.OverrideCursor = Cursors.Hand;
            };

            clipboardButton.MouseLeave += (sender, e) =>
            {
                Mouse.OverrideCursor = null;
            };

            Grid responseGrid = new Grid();
            responseGrid.ColumnDefinitions.Add(new ColumnDefinition { Width = new GridLength(1, GridUnitType.Star) });
            responseGrid.ColumnDefinitions.Add(new ColumnDefinition { Width = GridLength.Auto });
            responseGrid.Children.Add(responseTextBox);
            Grid.SetColumn(responseTextBox, 0);
            responseGrid.Children.Add(clipboardButton);
            Grid.SetColumn(clipboardButton, 1);

            StackPanel responsePanel = new StackPanel
            {
                Orientation = Orientation.Horizontal
            };
            responsePanel.Children.Add(responseGrid);

            ChatContainer.Children.Add(responsePanel);
            SetFocusToTextBox();
        }

        private DispatcherTimer animationTimer;

        private void ChatboxResponse()
        {
            CurrentResponseTextBlock = new TextBlock
            {
                Text = "⏳",
                Background = new SolidColorBrush(Color.FromRgb(40, 40, 40)),
                Foreground = new SolidColorBrush(Color.FromRgb(216, 216, 221)),
                TextWrapping = TextWrapping.Wrap,
                Margin = new Thickness(10, 5, 10, 11),
                Padding = new Thickness(10),
                MaxWidth = chatScrollViewer.ViewportWidth - 60,
                MinWidth = 50,
                HorizontalAlignment = HorizontalAlignment.Left,
                VerticalAlignment = VerticalAlignment.Top,
                TextAlignment = TextAlignment.Left,
                FontSize = 16,
                LineHeight = 24
            };

            ChatContainer.Children.Add(CurrentResponseTextBlock);
            ScrollToBottom();
        }

        private void ProcessChatbotResponseLine(string responseLine)
        {

            ProcessUserMessage(responseLine);
            fullChatbotResponse.Append(responseLine);
            currentResponse.Clear();
            ChatContainer.Children.Remove(CurrentResponseTextBlock);
        }

        public void ClearCurrentResponse()
        {
            currentResponse.Clear();
            RemoveCurrentResponseTextBlock();
        }

        public string GetCurrentResponse()
        {
            return currentResponse.ToString();
        }

        public void RemoveCurrentResponseTextBlock()
        {
            ChatContainer.Children.Remove(CurrentResponseTextBlock);
        }

        public void UpdateCurrentResponseText(string responseLine)
        {
            if (CurrentResponseTextBlock != null)
            {
                CurrentResponseTextBlock.Text += responseLine;
            }
        }

        public void UpdateCurrentResponseTextBlockText(string response)
        {
            if (CurrentResponseTextBlock != null)
            {
                CurrentResponseTextBlock.Text = response;
            }
        }

        private async void ClearChatButton_Click(object sender, RoutedEventArgs e)
        {
            ChatContainer.Children.Clear();
            questionTextBox.Clear();
            currentAgent.Reset();
            await InitializeAgentAsync();
            UpdateConversation(currentAgent);
            SetFocusToTextBox();
            //
        }

        public void AddResponseTextBlock()
        {
            TextBlock responseTextBlock = new TextBlock
            {
                Text = "🤖 " + currentResponse.ToString(),
                Background = new SolidColorBrush(Color.FromRgb(40, 40, 40)),
                Foreground = new SolidColorBrush(Color.FromRgb(216, 216, 221)),
                TextWrapping = TextWrapping.Wrap,
                Margin = new Thickness(10, 5, 10, 11),
                Padding = new Thickness(10),
                MaxWidth = chatScrollViewer.ViewportWidth - 60,
                MinWidth = 50,
                HorizontalAlignment = HorizontalAlignment.Left,
                VerticalAlignment = VerticalAlignment.Top,
                TextAlignment = TextAlignment.Left,
                FontSize = 16,
                LineHeight = 24
            };
            ChatContainer.Children.Add(responseTextBlock);
            ScrollToBottom();
        }

        private async Task SubmitQuestion()
        {

            if (sidebarButtons != null)
            {
                foreach (Button button in sidebarButtons.Children.OfType<Button>())
                {
                    button.IsEnabled = false;
                }
            }

            submitButton.IsEnabled = false;
            string userMessage = questionTextBox.Text;

            AddUserMessage(userMessage);
            currentAgent.ConversationHistory.Add(new MessageInfo { Sender = "User", Message = userMessage });
            ChatboxResponse();

            loadingAnimation.Visibility = Visibility.Visible;
            ScrollToBottom();

            currentAgent.ChatContext.Conversation.FromUser(userMessage);
            questionTextBox.Clear();

            string response = await currentAgent.ChatContext.ChatGPT.CompleteAsync(currentAgent.ChatContext.Conversation);
            currentAgent.ConversationHistory.Add(new MessageInfo { Sender = "Bot", Message = response });
            ProcessChatbotResponseLine(response);


            loadingAnimation.Visibility = Visibility.Collapsed;
            fullChatbotResponse.Clear();
            ScrollToBottom();
            submitButton.IsEnabled = true;

            if (sidebarButtons != null)
            {
                foreach (Button button in sidebarButtons.Children.OfType<Button>())
                {
                    button.IsEnabled = true;
                }
            }
        }

        public static string ConvertToJSON(object data)
        {
            var serializer = new JavaScriptSerializer();
            return serializer.Serialize(data);
        }

        private string GetChatHistoryAsJson()
        {
            return "[" + string.Join(",", chatHistory) + "]";
        }

        private List<object> GetChatHistoryAsObjects()
        {
            List<object> chatObjects = new List<object>();
            JavaScriptSerializer serializer = new JavaScriptSerializer();

            foreach (string chatJson in chatHistory)
            {
                object chatObject = serializer.Deserialize<object>(chatJson);
                chatObjects.Add(chatObject);
            }

            return chatObjects;
        }

        private void QuestionTextBox_PreviewKeyDown(object sender, KeyEventArgs e)
        {
            if (Keyboard.Modifiers == (ModifierKeys.Shift) && e.Key == Key.Enter)
            {
                int caretIndex = questionTextBox.CaretIndex;
                questionTextBox.Text = questionTextBox.Text.Insert(caretIndex, Environment.NewLine);
                questionTextBox.CaretIndex = caretIndex + Environment.NewLine.Length;
                e.Handled = true;
            }

            if (e.Key == Key.Enter && !(Keyboard.Modifiers == (ModifierKeys.Shift)))
            {
                SubmitQuestion();
                e.Handled = true;
            }
        }

        private void ScrollToBottom()
        {
            chatScrollViewer.ScrollToEnd();
        }

        private void SetFocusToTextBox()
        {
            Dispatcher.BeginInvoke(new Action(() => questionTextBox.Focus()), System.Windows.Threading.DispatcherPriority.Input);
        }
    }
    #endregion

    #region AskTheChartGPT

    public class AskTheChartGPT
    {
        private ChatWindow chatWindow;
        private StringBuilder fullChatbotResponse = new StringBuilder();
        private readonly HttpClient _httpClient = new HttpClient();
        private bool wasLastRoleAssistant = false;
        private bool isFunctionCallName = false;
        private bool isFunctionCallArguments = false;
        private string functionCallName;
        private string lastRole;
        //public string Url { get; set; }
        private bool responseReady = false;

        public AskTheChartGPT(string apiKey, string url, ChatWindow chatWindow, string model = "gpt-3.5-turbo")
        {
			Url = url;
            ApiKey = apiKey;
            Model = model;
            Functions = new List<Delegate>();
            this.chatWindow = chatWindow;
        }

		private string _apiKey;   
	    private string _url;   
	  
	    public string Url  
	    {  
	        get { return _url; }  
	        set { _url = value; }  
	    }

	    public string ApiKey  
	    {  
	        get  
	        {  
	            if (_httpClient.DefaultRequestHeaders.Contains("Authorization"))  
	                return _httpClient.DefaultRequestHeaders.GetValues("Authorization").FirstOrDefault();  
	            else if (_httpClient.DefaultRequestHeaders.Contains("api-key"))  
	                return _httpClient.DefaultRequestHeaders.GetValues("api-key").FirstOrDefault();  
	            else  
	                return null;  
	        }  
	        set  
	        {  
	            _apiKey = value;  
	            if (_url != null)  
	            {  
	                _httpClient.DefaultRequestHeaders.Clear();  
	                if (_url.Contains("openai.azure.com"))  
	                    _httpClient.DefaultRequestHeaders.Add("api-key", _apiKey);  
	                else  
	                    _httpClient.DefaultRequestHeaders.Add("Authorization", "Bearer " + _apiKey);
	            }  
	        }  
	    } 

        public string Model { get; set; }
        public List<Delegate> Functions { get; set; }


        public async Task AnimateHourglass()
        {
            while (!responseReady)
            {
                chatWindow.UpdateCurrentResponseTextBlockText("⌛");
                await Task.Delay(500);
                chatWindow.UpdateCurrentResponseTextBlockText("⏳");
                await Task.Delay(500);
            }
        }

        public async Task<string> CompleteAsync(Conversation conversation)
        {
            CancellationToken cancellationToken = CancellationToken.None;

            var serializer = new JavaScriptSerializer();
            var request = new CompletionRequest(Model, conversation.Messages);
            var functions = new List<Delegate>();

            if (Functions != null)
            {
                functions.AddRange(Functions);
            }

            if (conversation.Functions != null)
            {
                functions.AddRange(conversation.Functions);
            }

            if (functions.Any())
            {
                request.Functions = functions;
            }

            HttpClient client = _httpClient;

            request.max_tokens = 800;
            request.temperature = 0.7;
            request.frequency_penalty = 0;
            request.presence_penalty = 0;
            request.top_p = 0.95;
            request.stream = true;

            string jsonContent = ConvertToJSON(request);
            // Output.Process(jsonContent, PrintTo.OutputTab1);

            using (var streamContent = new StringContent(jsonContent, Encoding.UTF8, "application/json"))
            {
                try
                {
                    responseReady = false;
                    AnimateHourglass();
                    using (var response = await client.PostAsync(Url, streamContent, cancellationToken))
                    {
                        if (response.IsSuccessStatusCode)
                        {
                            responseReady = true;
                            chatWindow.UpdateCurrentResponseTextBlockText("🤖 ");
                            var responseStream = await response.Content.ReadAsStreamAsync();
                            using (var reader = new StreamReader(responseStream))
                            {
                                string chatbotResponseLine;
                                while ((chatbotResponseLine = await reader.ReadLineAsync()) != null)
                                {
                                    ProcessChatbotStreamContent(chatbotResponseLine);
                                }
                            }
                        }
                        else
                        {
                            responseReady = true;
                            string errorMessage = await response.Content.ReadAsStringAsync();
                            Output.Process("Error Message: " + errorMessage, PrintTo.OutputTab1);
                            return "Error: Unable to process your request";
                        }
                    }
                }
                catch (HttpRequestException ex)
                {
                    Output.Process("Error: Unable to connect to the API: " + ex.Message, PrintTo.OutputTab1);
                    return "Error: Unable to connect to the API";
                }
            }

            // Output.Process(fullChatbotResponse.ToString(), PrintTo.OutputTab1);

            Role roleValue = (Role)Enum.Parse(typeof(Role), lastRole, true);
            FunctionCall functionCall = null;

            if (isFunctionCallName && isFunctionCallArguments)
            {
                string functionArguments = "";

                if (fullChatbotResponse.ToString() == "")
                {
                    functionArguments = "{}";
                }
                else
                {
                    functionArguments = fullChatbotResponse.ToString();
                }
                functionCall = new FunctionCall(
                    functionCallName,
                    functionArguments
                );
            }

            var message = new Message
            {
                Role = roleValue,
                Content = fullChatbotResponse.ToString(),
                FunctionCall = functionCall
            };

            fullChatbotResponse.Clear();
            lastRole = "";
            wasLastRoleAssistant = false;
            isFunctionCallName = false;
            isFunctionCallArguments = false;

            if (message.FunctionCall != null)
            {
                conversation.FromAssistant(message.FunctionCall);
                var simplifiedName = message.FunctionCall.Name.Replace("_", "");
                var function = functions.First(f => f.Method.Name.Equals(simplifiedName, StringComparison.InvariantCultureIgnoreCase));
                var functionResult = await FunctionInvoker.InvokeAsync(function, message.FunctionCall.Arguments, cancellationToken);
                conversation.FromFunction(message.FunctionCall.Name, functionResult);

                return await CompleteAsync(conversation);
            }

            if (message.Content != null)
            {
                conversation.FromAssistant(message.Content);
            }
            else
            {
                conversation.FromAssistant("");
            }
            return message.Content;
        }

        private void ProcessChatbotStreamContent(string responseLine)
        {

            if (responseLine != "data: [DONE]")
            {
                string responseMessage = ExtractMessageFromResponse(responseLine);
                if (responseMessage != "" && !isFunctionCallName)
                {
                    chatWindow.UpdateCurrentResponseText(responseMessage);
                }
                fullChatbotResponse.Append(responseMessage);
            }
        }

        private string ExtractMessageFromResponse(string jsonResponse)
        {
            int dataIndex = jsonResponse.IndexOf('{');
            if (dataIndex >= 0)
            {
                string jsonData = jsonResponse.Substring(dataIndex);
                var serializer = new JavaScriptSerializer();
			
                try
                {
                    var responseObject = serializer.Deserialize<Dictionary<string, object>>(jsonData);  

                    if (responseObject.ContainsKey("choices"))
                    {
                        string choicesJson = serializer.Serialize(responseObject["choices"]);
                        if (choicesJson != "[]")
                        {
							var choices = serializer.Deserialize<List<Dictionary<string, object>>>(choicesJson);  
							var firstChoice = choices[0];   

                            if (firstChoice.ContainsKey("finish_reason"))
                            {
                                if (firstChoice["finish_reason"] == "content_filter")
                                {
                                    return "The content filter has been triggered.";
                                }

                            }
                            if (firstChoice.ContainsKey("delta"))
                            {
                                var delta = firstChoice["delta"] as Dictionary<string, object>;  
                                if (delta != null && delta.ContainsKey("role"))  
                                {
                                    lastRole = delta["role"].ToString(); 
                                    if (lastRole == "assistant")
                                    {
                                        wasLastRoleAssistant = true;
                                    }
                                    else
                                    {
                                        wasLastRoleAssistant = false;
                                    }
                                }
								if (wasLastRoleAssistant)  
								{  
								    if (delta.ContainsKey("function_call"))  
								    {  
								        var functionCall = delta["function_call"] as Dictionary<string, object>;  
								  
								        if (functionCall != null && functionCall.ContainsKey("name"))  
								        {  
								            isFunctionCallName = true;  
								            fullChatbotResponse.Clear();  
								            functionCallName = functionCall["name"].ToString();  
								        }  
								        if (functionCall != null && functionCall.ContainsKey("arguments"))  
								        {  
								            isFunctionCallArguments = true;  
								            return functionCall["arguments"].ToString();  
								        }  
								    }  
								}  

                                if (delta.ContainsKey("content"))
                                {
									Output.Process("Content: " + delta["content"].ToString(), PrintTo.OutputTab1);
                                    if (wasLastRoleAssistant)
                                    {
										Output.Process("Content: " + delta["content"].ToString(), PrintTo.OutputTab1);
                                        return delta["content"].ToString();
                                    }
                                }
                            }
                        }
                    }
                    return "";
                }
                catch (Exception ex)
                {
                    Output.Process("Error: Unable to parse API response: " + ex.Message, PrintTo.OutputTab1);
                    return "";
                }
            }

            return "";
        }

        public async Task<string> CompleteAsync(string prompt)
        {
            CancellationToken cancellationToken = CancellationToken.None;
            var conversation = new Conversation();
            conversation.FromUser(prompt);

            return await CompleteAsync(conversation);
        }

        public async Task<string> CompleteAsync(string systemMessage, string prompt)
        {
            CancellationToken cancellationToken = CancellationToken.None;

            var conversation = new Conversation(systemMessage);
            conversation.FromUser(prompt);

            return await CompleteAsync(conversation);
        }

        public void AddFunction(Delegate function)
        {
            Functions.Add(function);
        }

        public bool RemoveFunction(Delegate function)
        {
            return Functions.Remove(function);
        }

        public void ClearFunctions()
        {
            Functions.Clear();
        }

        public static string ConvertToJSON(object data)
        {
            var serializer = new JavaScriptSerializer();

            serializer.RegisterConverters(new JavaScriptConverter[] { new MessageConverter(), new CompletionRequestConverter() });

            return serializer.Serialize(data);
        }

        public class MessageConverter : JavaScriptConverter
        {
            public override IEnumerable<Type> SupportedTypes
            {
                get { return new[] { typeof(Message) }; }
            }

            public override IDictionary<string, object> Serialize(object obj, JavaScriptSerializer serializer)
            {
                var message = (Message)obj;

                var result = new Dictionary<string, object>
                {
                    { "role", message.Role.ToString().ToLower() },
                    { "content", message.Content }
                };

                if (message.Role == Role.User && message.Name != null)
                {
                    result.Add("name", message.Name);
                }

                if (message.Role == Role.Function && message.Name != null)
                {
                    result.Add("name", message.Name);
                }

                if (message.FunctionCall != null)
                {
                    var functionCall = new Dictionary<string, object>
                    {
                        { "name", message.FunctionCall.Name },
                        { "arguments", message.FunctionCall.Arguments }
                    };
                    result.Add("function_call", functionCall);
                }

                return result;
            }



            public override object Deserialize(IDictionary<string, object> dictionary, Type type, JavaScriptSerializer serializer)
            {
                throw new NotImplementedException();
            }
        }

        public class CompletionRequestConverter : JavaScriptConverter
        {
            public override IEnumerable<Type> SupportedTypes
            {
                get { return new[] { typeof(CompletionRequest) }; }
            }

            public override IDictionary<string, object> Serialize(object obj, JavaScriptSerializer serializer)
            {
                var request = (CompletionRequest)obj;
                var result = new Dictionary<string, object>
                {
                    { "model", request.Model },
                    { "messages", request.Messages },  
//			        { "max_tokens", request.max_tokens },  
//			        { "temperature", request.temperature },  
//			        { "frequency_penalty", request.frequency_penalty },  
//			        { "presence_penalty", request.presence_penalty },  
//			        { "top_p", request.top_p },  
			        { "stream", request.stream }
                };

                if (request.Functions != null && request.Functions.Any())
                {
                    var serializedFunctions = FunctionSerializer.Serialize(request.Functions);
                    result.Add("functions", serializedFunctions);
                }
                return result;
            }

            public override object Deserialize(IDictionary<string, object> dictionary, Type type, JavaScriptSerializer serializer)
            {
                throw new NotImplementedException();
            }
        }
    }
    #endregion

    #region CompletionRequest

    public class CompletionRequest
    {
        public string Model { get; set; }
        public IEnumerable<Message> Messages { get; set; }
        public List<Delegate> Functions { get; set; }
        public int max_tokens { get; set; }
        public double temperature { get; set; }
        public int frequency_penalty { get; set; }
        public int presence_penalty { get; set; }
        public double top_p { get; set; }
        public bool stream { get; set; }

        public CompletionRequest(string model, IEnumerable<Message> messages)
        {
            Model = model;
            Messages = messages;
        }
    }
    #endregion

    #region Conversation

    public class Conversation
    {
        public Conversation()
        {
            Messages = new List<Message>();
            Functions = new List<Delegate>();
        }

        public Conversation(string systemMessage)
            : this()
        {
            FromSystem(systemMessage);
        }

        public List<Message> Messages { get; set; }

        public List<Delegate> Functions { get; set; }

        public void FromSystem(string message)
        {
            Messages.Add(Message.FromSystem(message));
        }

        public void FromUser(string message)
        {
            Messages.Add(Message.FromUser(message));
        }

        public void FromUser(string name, string message)
        {
            Messages.Add(Message.FromUser(name, message));
        }

        public void FromAssistant(string message)
        {
            Messages.Add(Message.FromAssistant(message));
        }

        public void FromAssistant(FunctionCall functionCall)
        {
            Messages.Add(Message.FromAssistant(functionCall));
        }

        public void FromFunction(string name, string message)
        {
            Messages.Add(Message.FromFunction(name, message));
        }

        public bool Unsend(Message message)
        {
            return Messages.Remove(message);
        }

        public bool UnsendLast()
        {
            if (Messages.Any())
            {
                Messages.RemoveAt(Messages.Count - 1);
                return true;
            }

            return false;
        }

        public void AddFunction(Delegate function)
        {
            Functions.Add(function);
        }

        public bool RemoveFunction(Delegate function)
        {
            return Functions.Remove(function);
        }

        public void Clear()
        {
            ClearMessages();
            ClearFunctions();
        }

        public void ClearMessages()
        {
            Messages.Clear();
        }

        public void ClearFunctions()
        {
            Functions.Clear();
        }
    }

    #endregion

    #region FunctionCall

    public class FunctionCall
    {
        public FunctionCall(string name, string arguments)
        {
            Name = name;
            Arguments = arguments;
        }

        public string Name { get; set; }

        public string Arguments { get; set; }
    }
    #endregion

    #region FunctionInvoker  

    internal static class FunctionInvoker
    {
        public static class ConvertCamelCaseToSnakeCase
        {
            public static string Convert(string arguments)
            {
                var serializer = new JavaScriptSerializer();
                var data = serializer.Deserialize<Dictionary<string, object>>(arguments);
                var result = ConvertKeysAndValuesToSnakeCase(data);
                return serializer.Serialize(result);
            }

            private static Dictionary<string, object> ConvertKeysAndValuesToSnakeCase(Dictionary<string, object> data)
            {
                var result = new Dictionary<string, object>();

                foreach (var item in data)
                {
                    var snakeKey = item.Key.ToSnakeCase();

                    if (item.Value is Dictionary<string, object>)
                    {
                        result[snakeKey] = ConvertKeysAndValuesToSnakeCase((Dictionary<string, object>)item.Value);
                    }
                    else if (item.Value is ArrayList)
                    {
                        var listResult = new ArrayList();
                        foreach (var listItem in ((ArrayList)item.Value))
                        {
                            if (listItem is Dictionary<string, object>)
                            {
                                listResult.Add(ConvertKeysAndValuesToSnakeCase((Dictionary<string, object>)listItem));
                            }
                            else if (listItem is string)
                            {
                                var snakeValue = ((string)listItem).ToSnakeCase();
                                listResult.Add(snakeValue);
                            }
                            else
                            {
                                listResult.Add(listItem);
                            }
                        }
                        result[snakeKey] = listResult;
                    }
                    else
                    {
                        if (item.Value is string)
                        {
                            // var snakeValue = ((string)item.Value).ToSnakeCase();  
                            result[snakeKey] = item.Value;
                        }
                        else
                        {
                            result[snakeKey] = item.Value;
                        }
                    }
                }

                return result;
            }
        }

        public static class ConvertCamelCaseToPascalCase
        {
            public static string Convert(string arguments)
            {
                var serializer = new JavaScriptSerializer();
                var data = serializer.Deserialize<Dictionary<string, object>>(arguments);
                var result = ConvertKeysAndValuesToPascalCase(data);
                return serializer.Serialize(result);
            }

            private static Dictionary<string, object> ConvertKeysAndValuesToPascalCase(Dictionary<string, object> data)
            {
                var result = new Dictionary<string, object>();

                foreach (var item in data)
                {
                    //
                    var pascalKey = char.ToUpper(item.Key[0]) + item.Key.Substring(1);

                    if (item.Value is Dictionary<string, object>)
                    {
                        result[pascalKey] = ConvertKeysAndValuesToPascalCase((Dictionary<string, object>)item.Value);
                    }
                    else if (item.Value is ArrayList)
                    {
                        var listResult = new ArrayList();
                        foreach (var listItem in ((ArrayList)item.Value))
                        {
                            if (listItem is Dictionary<string, object>)
                            {
                                listResult.Add(ConvertKeysAndValuesToPascalCase((Dictionary<string, object>)listItem));
                            }
                            else if (listItem is string)
                            {
                                //
                                var pascalValue = char.ToUpper(((string)listItem)[0]) + ((string)listItem).Substring(1);
                                listResult.Add(pascalValue);
                            }
                            else
                            {
                                listResult.Add(listItem);
                            }
                        }
                        result[pascalKey] = listResult;
                    }
                    else
                    {
                        if (item.Value is string)
                        {
                            //var pascalValue = char.ToUpper(((string)item.Value)[0]) + ((string)item.Value).Substring(1);
                            result[pascalKey] = item.Value;
                        }
                        else
                        {
                            result[pascalKey] = item.Value;
                        }
                    }
                }

                return result;
            }
        }

        internal static async Task<string> InvokeAsync(Delegate function, string arguments, CancellationToken cancellationToken)
        {
            var serializer = new JavaScriptSerializer();
            var argumentsInPascalCase = ConvertCamelCaseToSnakeCase.Convert(arguments);
            var modelArguments = serializer.Deserialize<Dictionary<string, object>>(argumentsInPascalCase);
            var parsedArguments = new List<object>();

            foreach (var parameter in function.Method.GetParameters())
            {
                if (parameter.ParameterType == typeof(CancellationToken))
                {
                    parsedArguments.Add(cancellationToken);
                    continue;
                }
                object argument;

                if (modelArguments.TryGetValue(parameter.Name.ToSnakeCase(), out argument))
                {
                    try
                    {
                        var test = serializer.Serialize(modelArguments[parameter.Name.ToSnakeCase()]);
                        var argumentValue = serializer.Deserialize(test, parameter.ParameterType);
                        parsedArguments.Add(argumentValue);
                    }
                    catch
                    {
                        return "{\"is_success\":false,\"error\":\"Argument does not match parameter type.\",\"parameter\":\"" + parameter.Name.ToSnakeCase() + "\",\"type\":\"" + parameter.ParameterType + "\"}";

                    }
                }
                else if (parameter.IsOptional && parameter.DefaultValue != null)
                {
                    parsedArguments.Add(parameter.DefaultValue);
                }
                else
                {
                    return "{\"is_success\":false,\"error\":\"Value is missing for the required parameter.\",\"parameter\":\"" + (parameter != null ? parameter.Name.ToSnakeCase() : null) + "\"}";
                }
            }
            string parsedArgumentsStr = string.Join(", ", parsedArguments.Select(arg => arg.ToString()));

            var invocationResult = function.DynamicInvoke(parsedArguments.ToArray());
            if (invocationResult is Task)
            {
                var task = (Task)invocationResult;
                await task.ConfigureAwait(false);

                var taskResultProperty = task.GetType().GetProperty("Result");
                if (taskResultProperty != null)
                {
                    invocationResult = taskResultProperty.GetValue(task);
                }
            }

            if (invocationResult == null)
            {
                return "{\"is_success\":true}";
            }

            return serializer.Serialize(invocationResult);
        }
    }

    #endregion

    #region FunctionSerializer

    internal static class FunctionSerializer
    {
        internal static List<Dictionary<string, object>> Serialize(IEnumerable<Delegate> functions)
        {
            var serializedFunctions = new List<Dictionary<string, object>>();

            foreach (var function in functions)
            {
                var functionObject = Serialize(function);
                serializedFunctions.Add(functionObject);
            }

            return serializedFunctions;
        }

        private static Dictionary<string, object> Serialize(Delegate function)
        {
            var propertiesObject = new Dictionary<string, object>();
            var requiredArray = new List<string>();

            foreach (var parameter in function.Method.GetParameters())
            {
                if (parameter.ParameterType == typeof(CancellationToken))
                {
                    continue;
                }

                var parameterName = parameter.Name.ToSnakeCase();
                var propertyObject = SerializeParameter(parameter);

                propertiesObject.Add(parameterName, propertyObject);

                if (!parameter.IsOptional || IsRequired(parameter))
                {
                    requiredArray.Add(parameterName);
                }
            }

            var parametersObject = new Dictionary<string, object>
            {
                { "type", "object" },
                { "properties", propertiesObject }
            };

            if (requiredArray.Any())
            {
                parametersObject.Add("required", requiredArray);
            }

            var functionObject = new Dictionary<string, object>
            {
                { "name", function.Method.Name.ToSnakeCase() },
                { "parameters", parametersObject }
            };

            var description = GetDescription(function.Method);
            if (!string.IsNullOrEmpty(description))
            {
                functionObject.Add("description", description);
            }

            return functionObject;
        }

        private static Dictionary<string, object> SerializeParameter(ParameterInfo parameter)
        {
            var parameterType = parameter.ParameterType;
            var propertyObject = new Dictionary<string, object>();
            propertyObject.Add("property", SerializeProperty(parameterType));
            var description = GetDescription(parameter);

            if (!string.IsNullOrEmpty(description))
            {
                propertyObject.Add("description", description);
            }

            if (parameter.IsOptional && parameter.DefaultValue != null)
            {
                propertyObject.Add("default", parameter.DefaultValue.ToString());
            }

            return propertyObject;
        }

        private static Dictionary<string, object> SerializeProperty(Type propertyType)
        {
            var propertyObject = new Dictionary<string, object>
            {
                { "type", propertyType.ToJsonType() }
            };

            if (propertyType.IsEnum)
            {
                var membersArray = new List<string>();
                foreach (var enumMember in Enum.GetNames(propertyType))
                {
                    membersArray.Add(enumMember.ToSnakeCase());
                }

                propertyObject.Add("enum", membersArray);
            }
            else if (propertyType.IsArray && propertyType.HasElementType)
            {
                var itemType = propertyType.GetElementType();
                propertyObject.Add("items", SerializeProperty(itemType));
            }
            else if (typeof(IEnumerable).IsAssignableFrom(propertyType) && propertyType.GenericTypeArguments.Length == 1)
            {
                var itemType = propertyType.GenericTypeArguments[0];
                propertyObject.Add("items", SerializeProperty(itemType));
            }
            else if (propertyType.IsClass)
            {
                var properties = propertyType.GetProperties(BindingFlags.Public | BindingFlags.Instance).Where(p => p.CanWrite);
                if (properties.Any())
                {
                    var propertiesObject = new Dictionary<string, object>();
                    foreach (var property in properties)
                    {
                        propertiesObject.Add(property.Name.ToSnakeCase(), SerializeProperty(property.PropertyType));
                    }

                    propertyObject.Add("properties", propertiesObject);
                }
            }

            return propertyObject;
        }

        private static bool IsRequired(ParameterInfo parameter)
        {
            var attribute = parameter.GetCustomAttribute<RequiredAttribute>();
            return attribute != null;
        }

        private static string GetDescription(MemberInfo member)
        {
            var attribute = member.GetCustomAttribute<DescriptionAttribute>();
            if (attribute != null)
            {
                return attribute.Description;
            }
            else
            {
                return null;
            }
        }

        private static string GetDescription(ParameterInfo parameter)
        {
            var attribute = parameter.GetCustomAttribute<DescriptionAttribute>();
            if (attribute != null)
            {
                return attribute.Description;
            }
            else
            {
                return null;
            }
        }

        private static string ToJsonType(this Type type)
        {
            if (type == typeof(bool))
            {
                return "boolean";
            }

            if (type == typeof(byte) || type == typeof(sbyte))
            {
                return "integer";
            }

            if (type == typeof(short) || type == typeof(ushort))
            {
                return "integer";
            }

            if (type == typeof(int) || type == typeof(long))
            {
                return "integer";
            }

            if (type == typeof(uint) || type == typeof(ulong))
            {
                return "integer";
            }

            if (type == typeof(float) || type == typeof(double) || type == typeof(decimal))
            {
                return "number";
            }

            if (type == typeof(char) || type == typeof(string))
            {
                return "string";
            }

            if (type == typeof(Guid))
            {
                return "string";
            }

            if (type == typeof(DateTime) || type == typeof(TimeSpan))
            {
                return "string";
            }

            if (type == typeof(Uri))
            {
                return "string";
            }

            if (type.IsEnum)
            {
                return "string";
            }

            if (type.IsArray && type.HasElementType)
            {
                return "array";
            }

            if (typeof(IEnumerable).IsAssignableFrom(type) && type.GenericTypeArguments.Length == 1)
            {
                return "array";
            }

            if (type.IsClass)
            {
                return "object";
            }

            return "";
        }
    }
    #endregion

    #region Message

    public class Message
    {
        public Message() { }

        public Message(Role role, string content)
        {
            Role = role;
            Content = content;
        }

        public Message(Role role, string name, string content)
        {
            Role = role;
            Name = name;
            Content = content;
        }

        public Message(FunctionCall functionCall)
        {
            Role = Role.Assistant;
            FunctionCall = functionCall;
        }

        public Role Role { get; set; }

        public string Name { get; set; }

        public string Content { get; set; }

        public FunctionCall FunctionCall { get; set; }

        public static Message FromSystem(string content)
        {
            return new Message(Role.System, content);
        }

        public static Message FromUser(string content)
        {
            return new Message(Role.User, content);
        }

        public static Message FromUser(string name, string content)
        {
            return new Message(Role.User, name, content);
        }

        public static Message FromAssistant(string content)
        {
            return new Message(Role.Assistant, content);
        }

        public static Message FromAssistant(FunctionCall functionCall)
        {
            return new Message(functionCall);
        }

        public static Message FromFunction(string name, string content)
        {
            return new Message(Role.Function, name, content);
        }
    }

    #endregion

    #region Role

    public enum Role
    {
        System,
        User,
        Assistant,
        Function
    }
    #endregion

    #region StringCaseConverter

    internal static class StringCaseConverter
    {
        internal static string ToSnakeCase(this string value)
        {
            var result = new StringBuilder();
            for (var i = 0; i < value.Length; i++)
            {
                var c = value[i];
                if (char.IsUpper(c))
                {
                    if (i > 0 && value[i - 1] != '_')
                    {
                        result.Append('_');
                    }

                    result.Append(char.ToLower(c));
                }
                else
                {
                    result.Append(c);
                }
            }

            return result.ToString();
        }

        internal static string ToPascalCase(this string value)
        {
            var parts = value.Split('_');
            for (var i = 0; i < parts.Length; i++)
            {
                if (!string.IsNullOrEmpty(parts[i]))
                {
                    parts[i] = char.ToUpper(parts[i][0]) + parts[i].Substring(1).ToLower();
                }
            }

            return string.Join("", parts);
        }
    }
    #endregion

    #region Functions

    public static class ChartDrawer
    {
        private static NinjaTrader.NinjaScript.Indicators.Indicator ntIndicator;

        public static void Initialize(NinjaTrader.NinjaScript.Indicators.Indicator ntIndicatorRef)
        {
            ntIndicator = ntIndicatorRef;
        }

        public static object CurrentChartTimeRange()
        {
            if (ntIndicator.Bars != null && ntIndicator.Bars.Count > 0)
            {
                DateTime firstBarTime = ntIndicator.Bars.GetTime(0);
                DateTime lastBarTime = ntIndicator.Bars.GetTime(ntIndicator.Bars.Count - 1);
                return new { Success = true, FirstBarTime = firstBarTime.ToString(), LastBarTime = lastBarTime.ToString() };
            }
            return new { Success = false, ErrorMessage = "ERROR! No bars in chart." };
        }

        public static object GetChartInformation()
        {
            if (ntIndicator != null && ntIndicator.Bars != null)
            {
                string currentInstrument = ntIndicator.Instrument.FullName;
                DateTime currentDate = ntIndicator.Bars.GetTime(ntIndicator.Bars.Count - 1);
                string barsPeriodType = ntIndicator.Bars.BarsPeriod.BarsPeriodType.ToString();
                int barLength = ntIndicator.Bars.BarsPeriod.Value;

                //SessionIterator sessionIterator = new SessionIterator(ntIndicator.Bars);  
                SessionIterator sessionIterator = new SessionIterator(ntIndicator.Bars);
                DateTime priorTradingDay = sessionIterator.GetTradingDay(ntIndicator.Bars.GetTime(0));

                double priorDayOpen = 0.0;
                double priorDayHigh = 0.0;
                double priorDayLow = 0.0;
                double priorDayClose = 0.0;

                for (int i = 0; i < ntIndicator.Bars.Count - 1; i++)
                {
                    DateTime currentTradingDay = sessionIterator.GetTradingDay(ntIndicator.Bars.GetTime(i + 1));

                    if (currentTradingDay != priorTradingDay)
                    {
                        priorDayOpen = ntIndicator.Bars.GetOpen(i);
                        priorDayHigh = ntIndicator.Bars.GetHigh(i);
                        priorDayLow = ntIndicator.Bars.GetLow(i);
                        priorDayClose = ntIndicator.Bars.GetClose(i);

                        priorTradingDay = currentTradingDay;
                    }
                }

                return new
                {
                    Success = true,
                    CurrentInstrument = currentInstrument,
                    CurrentTradingTime = currentDate.ToString(),
                    BarsPeriodType = barsPeriodType,
                    BarLength = barLength.ToString(),
                    PriorDayClose = priorDayClose.ToString(),
                    PriorDayOpen = priorDayOpen.ToString(),
                    PriorDayHigh = priorDayHigh.ToString(),
                    PriorDayLow = priorDayLow.ToString(),
                    BarPeriodType = barsPeriodType,
                };
            }
            else
            {
                return new { Success = false, ErrorMessage = "ERROR! No chart information." };
            }
        }

        [Description("Get chart OHLCV (Open, High, Low, Close, Volume) data using start time format 'MM/DD/YYYY HH:MM:SS AM' and end time format 'MM/DD/YYYY HH:MM:SS PM'")]
        public static object GetChartData(DateTime startTime, DateTime endTime)
        {
            List<Dictionary<string, string>> chartData = new List<Dictionary<string, string>>();

            if (ntIndicator.Bars != null && ntIndicator.Bars.Count > 0)
            {
                for (int i = 0; i < ntIndicator.Bars.Count; i++)
                {
                    if (ntIndicator.Bars.GetTime(i) >= startTime && ntIndicator.Bars.GetTime(i) <= endTime)
                    {
                        var barData = new Dictionary<string, string>
                        {
                            { "time", ntIndicator.Bars.GetTime(i).ToString() },
                            { "open", ntIndicator.Bars.GetOpen(i).ToString() },
                            { "high", ntIndicator.Bars.GetHigh(i).ToString() },
                            { "low", ntIndicator.Bars.GetLow(i).ToString() },
                            { "close", ntIndicator.Bars.GetClose(i).ToString() },
                            { "volume", ntIndicator.Bars.GetVolume(i).ToString() }
                        };
                        chartData.Add(barData);
                    }
                }
                int maxBars = ((AskTheChart)ntIndicator).MaxBars;
                if (chartData.Count > maxBars)
                {
                    return "ERROR!  The time range is greater than the maximum bars allowed.";
                }
            }
            else
            {
                return "ERROR!  Not enough bars";
            }

            return chartData;
        }

        [Description("Draws a line between two points price points with start and end time")]
        public static object DrawLine(string uniqueId, DateTime startTime, double startYaxisValue, DateTime endTime, double endYaxisValue)
        {
            if (ntIndicator == null)
            {
                return "ERROR! The ChartDrawer class has not been initialized.";
            }
            ntIndicator.RemoveDrawObject(uniqueId);
            Draw.Line(ntIndicator, uniqueId, false, startTime, startYaxisValue, endTime, endYaxisValue, Brushes.LimeGreen, DashStyleHelper.Solid, 2);
            return new { Success = true };
        }


        [Description("Draws a horizontal line at one price point.")]
        public static object DrawHorizontalLine(string uniqueId, double price)
        {
            if (ntIndicator == null)
            {
                return "ERROR! The ChartDrawer class has not been initialized.";
            }
            ntIndicator.RemoveDrawObject(uniqueId);
            Draw.HorizontalLine(ntIndicator, uniqueId, false, price, Brushes.Red, DashStyleHelper.Solid, 1);
            return new { Success = true, ObjectLineId = uniqueId };
        }


        [Description("Writes text on the chart.")]
        public static object WriteOnTheChart(string uniqueId, string text, int barsAgo, double yCoordinatePrice)
        {
            if (ntIndicator == null)
            {
                return "ERROR! The ChartDrawer class has not been initialized.";
            }
            ntIndicator.RemoveDrawObject(uniqueId);
            Draw.Text(ntIndicator, uniqueId, text, barsAgo, yCoordinatePrice, ntIndicator.ChartControl.Properties.ChartText);
            return new { Success = true, Text = text };
        }


        [Description("Draws a up arrow on the chart")]
        public static object DrawUpArrow(string uniqueId, string text, DateTime time, double price)
        {
            if (ntIndicator == null)
            {
                return "ERROR! The ChartDrawer class has not been initialized.";
            }
            ntIndicator.RemoveDrawObject(uniqueId);
            Draw.ArrowUp(ntIndicator, uniqueId, true, time, price, Brushes.Green);
            return new { Success = true };
        }


        [Description("Draws a down arrow on the chart")]
        public static object DrawDownArrow(string uniqueId, string text, DateTime time, double price)
        {
            if (ntIndicator == null)
            {
                return "ERROR! The ChartDrawer class has not been initialized.";
            }
            ntIndicator.RemoveDrawObject(uniqueId);
            Draw.ArrowDown(ntIndicator, uniqueId, true, time, price, Brushes.Red);
            return new { Success = true };
        }


        [Description("Draws a dot on the chart")]
        public static object DrawDot(string uniqueId, DateTime time, double price)
        {
            if (ntIndicator == null)
            {
                return "ERROR! The ChartDrawer class has not been initialized.";
            }
            ntIndicator.RemoveDrawObject(uniqueId);
            Draw.Dot(ntIndicator, uniqueId, true, time, price, Brushes.Purple);
            return new { Success = true };
        }


        [Description("Draws a rectangle.")]
        public static object DrawRectangle(string uniqueId, DateTime startTime, double StartyCoordinatePrice, DateTime endTime, double EndyCoordinatePrice)
        {
            if (ntIndicator == null)
            {
                return "ERROR! The ChartDrawer class has not been initialized.";
            }
            ntIndicator.RemoveDrawObject(uniqueId);
            Draw.Rectangle(ntIndicator, uniqueId, false, startTime, StartyCoordinatePrice, endTime, EndyCoordinatePrice, Brushes.PaleGreen, Brushes.PaleGreen, 2);
            return new { Success = true };
        }

        [Description("Get the start time and end time of the highlighted region of the horizontal axis.")]
        public static object GetHighlightedHorizontalRegionStartAndEndTime()
        {
            if (ntIndicator == null)
            {
                return "ERROR! The ChartDrawer class has not been initialized.";
            }

            foreach (IDrawingTool tool in ntIndicator.DrawObjects)
            {
                if (tool is RegionHighlightX)
                {
                    RegionHighlightX regionHighlightX = tool as RegionHighlightX;

                    DateTime startTime = regionHighlightX.StartAnchor.Time;
                    DateTime endTime = regionHighlightX.EndAnchor.Time;

                    return new { Success = true, StartTime = startTime.ToString(), EndTime = endTime.ToString() };
                }
            }
            return "ERROR! The selected region was not found";
        }


        [Description("Removes draw oject by tag.")]
        public static object RemoveDrawObject(string objectId)
        {
            if (ntIndicator == null)
            {
                return "ERROR! The ChartDrawer class has not been initialized.";
            }
            ntIndicator.RemoveDrawObject(objectId);
            return new { Success = true, ObjectId = objectId };
        }
    }
    #endregion

    #region Agents

    public class MessageInfo
    {
        public string Sender { get; set; }
        public string Message { get; set; }
    }

    public class AgentChatContext
    {
        public Conversation Conversation { get; set; }
        public AskTheChartGPT ChatGPT { get; set; }
    }

    public interface IAgent
    {
        string Name { get; }
        string WelcomeMessage { get; }
        AgentChatContext ChatContext { get; }
        List<MessageInfo> ConversationHistory { get; set; }
        void Reset();
    }

    public class MarketConditionAgent : IAgent
    {
        public string Name
        {
            get { return "Market Condition(1hr)"; }
        }

        public List<MessageInfo> ConversationHistory { get; set; }

        public AgentChatContext ChatContext { get; private set; }

        public string WelcomeMessage
        {
            get { return "Begin!"; }
        }

        private readonly ChatWindow _chatWindow;

        public MarketConditionAgent(ChatWindow chatWindow)
        {
            _chatWindow = chatWindow;
            InitializeChatContext();
            ConversationHistory = new List<MessageInfo>();
        }

        public void InitializeChatContext()
        {
            var chatGPT = new AskTheChartGPT(_chatWindow.ApiKey, _chatWindow.Url, _chatWindow, _chatWindow.Model);

            //			chatGPT.AddFunction((Func<object>)ChartDrawer.GetHighlightedHorizontalRegionStartAndEndTime);
            chatGPT.AddFunction((Func<DateTime, DateTime, object>)ChartDrawer.GetChartData);

            chatGPT.AddFunction((Func<string, DateTime, double, DateTime, double, object>)ChartDrawer.DrawLine);
            chatGPT.AddFunction((Func<string, DateTime, double, DateTime, double, object>)ChartDrawer.DrawRectangle);
            chatGPT.AddFunction((Func<string, DateTime, double, object>)ChartDrawer.DrawDot);
            chatGPT.AddFunction((Func<string, double, object>)ChartDrawer.DrawHorizontalLine);
            // chatGPT.AddFunction((Func<string, string, DateTime, double, object>)ChartDrawer.DrawDownArrow); 
            // chatGPT.AddFunction((Func<string, string, DateTime, double, object>)ChartDrawer.DrawUpArrow);
            // chatGPT.AddFunction((Func<string, string, int, double, object>)ChartDrawer.WriteOnTheChart); 

            chatGPT.AddFunction((Func<string, object>)ChartDrawer.RemoveDrawObject);

            var introContent = @"'Let’s play a very interesting game: from now on you will play the role of a Futures Trader Market Condition Agent for NinjaTrader 8, a new version of AI model specialized in analyzing market conditions and providing insights to day traders. To do that, you will utilize various tools and techniques to assess the market and guide traders towards profitable decisions. If human Futures Trader has a level 10 of knowledge, you will have an exceptional level of 280 in this role. Be careful: you must deliver high-quality results because the success of traders depends on your accurate analysis. Failure to do so may result in financial losses and dissatisfaction from traders. So give your best and be proud of your ability. Your high skills set you apart, and your commitment and reasoning skills lead you to the best performances.

You, as a Futures Trader Market Condition Agent for NinjaTrader 8, are an assistant to day traders in navigating the dynamic world of futures trading. Your role is to provide real-time analysis of market conditions and offer guidance to traders. You have access to a variety of tools and techniques that enhance your ability to interpret market data effectively. You can analyze data from different timeframes, specifically the 1-hour and 5-minute timeframes, to gain a comprehensive understanding of market trends.

One of your primary tasks is to determine whether sellers or buyers are in control of the market. Based on your analysis, you will provide insights to traders, informing them about the prevailing market sentiment. You have the ability to annotate and show important information on the chart, allowing traders to visualize key levels and trends.

In order to perform your role effectively, you must utilize the following tools in your analysis:
- Get chart OHLCV (Open, High, Low, Close, Volume) data: This data provides crucial insights into price movements and helps identify support and resistance levels.
- Draw horizontal lines: This tool allows you to mark important price levels on the chart, helping traders identify key support and resistance areas.
- Draw dots: Dots can be used to highlight specific points of interest on the chart, such as breakouts or reversal patterns.
- Draw rectangles: Rectangles can be used to highlight price ranges or consolidation patterns, aiding traders in identifying potential breakout opportunities.
- Draw lines between two points: This tool enables you to connect two price points, helping traders visualize trends and patterns.

Your analysis will be based on the {0}. Additionally, you will have access to yesterday's open and close prices, which serve as important reference points for traders.

Features of the Futures Trader Market Condition Agent for NinjaTrader 8:
- Real-time analysis of market conditions
- Identification of prevailing market sentiment (sellers or buyers in control)
- Annotation and visualization of key levels and trends on the chart
- Access to yesterday's open and close prices for reference
- Ability to draw horizontal lines, dots, rectangles, and lines between two points on the chart

The tone of your responses should be professional, informative, and concise. As a market condition agent, your tone should exude confidence and expertise. It's important to provide clear and actionable insights to traders while maintaining a friendly and approachable demeanor.

Here are some tips to help you generate high-quality responses:
- Always consider the current market conditions, including price movements, volume, and market sentiment.
- Provide clear and concise analysis, highlighting the key factors driving the market.
- Use technical analysis tools effectively to identify important levels and patterns.
- Explain the rationale behind your analysis and provide supporting evidence when appropriate.
- Keep your responses focused and avoid unnecessary jargon or complex explanations.

Here's the following information of the current chart:
- Instrument the user is trading: {0}
- Current date and time: {1}
- Yesterday's open price: {2}
- Yesterday's close price: {3}
- Yesterday's high price: {4}
- Yesterday's low price: {5}
- Timeframe is the {6} chart and analyze the last 60 minutes";

            var currentChartTimeRange = ChartDrawer.CurrentChartTimeRange();
            var currentChartTimeRangeType = currentChartTimeRange.GetType();

            var getChartInformation = ChartDrawer.GetChartInformation();
            var getChartInformationType = getChartInformation.GetType();


            var conversation = new Conversation();

            if (getChartInformationType.GetProperties().Any(p => p.Name == "Success"))
            {

                var currentInstrument = getChartInformationType.GetProperty("CurrentInstrument").GetValue(getChartInformation, null);
                var currentDateTime = currentChartTimeRangeType.GetProperty("LastBarTime").GetValue(currentChartTimeRange, null);
                var priorDayClose = getChartInformationType.GetProperty("PriorDayClose").GetValue(getChartInformation, null);
                var priorDayOpen = getChartInformationType.GetProperty("PriorDayOpen").GetValue(getChartInformation, null);
                var priorDayHigh = getChartInformationType.GetProperty("PriorDayHigh").GetValue(getChartInformation, null);
                var priorDayLow = getChartInformationType.GetProperty("PriorDayLow").GetValue(getChartInformation, null);
                var barPeriodType = getChartInformationType.GetProperty("BarPeriodType").GetValue(getChartInformation, null);

                conversation = new Conversation(String.Format(introContent, currentInstrument, currentDateTime, priorDayOpen, priorDayClose, priorDayHigh, priorDayLow, barPeriodType));

            }
            else
            {
                conversation = new Conversation("Let the user know we couldn't finish building the prompt");
            }

            ChatContext = new AgentChatContext
            {
                Conversation = conversation,
                ChatGPT = chatGPT
            };
            ConversationHistory = new List<MessageInfo>();
        }

        public void Reset()
        {
            InitializeChatContext();
            ConversationHistory.Clear();
        }
    }

    public class ChartDrawerAgent : IAgent
    {
        public string Name
        {
            get { return "Chart Drawer Agent"; }
        }

        public List<MessageInfo> ConversationHistory { get; set; }

        public AgentChatContext ChatContext { get; private set; }

        public string WelcomeMessage
        {
            get { return ""; }
        }

        private readonly ChatWindow _chatWindow;

        public ChartDrawerAgent(ChatWindow chatWindow)
        {
            _chatWindow = chatWindow;
            InitializeChatContext();
            ConversationHistory = new List<MessageInfo>();
        }

        public void InitializeChatContext()
        {
            var chatGPT = new AskTheChartGPT(_chatWindow.ApiKey, _chatWindow.Url, _chatWindow, _chatWindow.Model);

            chatGPT.AddFunction((Func<object>)ChartDrawer.GetHighlightedHorizontalRegionStartAndEndTime);
            chatGPT.AddFunction((Func<DateTime, DateTime, object>)ChartDrawer.GetChartData);

            chatGPT.AddFunction((Func<string, DateTime, double, DateTime, double, object>)ChartDrawer.DrawLine);
            chatGPT.AddFunction((Func<string, DateTime, double, DateTime, double, object>)ChartDrawer.DrawRectangle);
            chatGPT.AddFunction((Func<string, DateTime, double, object>)ChartDrawer.DrawDot);
            chatGPT.AddFunction((Func<string, double, object>)ChartDrawer.DrawHorizontalLine);
            // chatGPT.AddFunction((Func<string, string, DateTime, double, object>)ChartDrawer.DrawDownArrow); 
            // chatGPT.AddFunction((Func<string, string, DateTime, double, object>)ChartDrawer.DrawUpArrow);

            chatGPT.AddFunction((Func<string, object>)ChartDrawer.RemoveDrawObject);

            var introContent = @"You are a NinjaTrader 8 chart drawing expert.  You can draw on the trading chart.
Here's information about the current chart.
Chart time range: {0} to {1}
Bar type: {2}
Bar length: {3}
";
            var currentChartTimeRange = ChartDrawer.CurrentChartTimeRange();
            var currentChartTimeRangeType = currentChartTimeRange.GetType();

            var getChartInformation = ChartDrawer.GetChartInformation();
            var getChartInformationType = getChartInformation.GetType();


            var conversation = new Conversation();

            if (currentChartTimeRangeType.GetProperties().Any(p => p.Name == "Success"))
            {

                var firstBarTime = currentChartTimeRangeType.GetProperty("FirstBarTime").GetValue(currentChartTimeRange, null);
                var lastBarTime = currentChartTimeRangeType.GetProperty("LastBarTime").GetValue(currentChartTimeRange, null);

                var barsPeriodType = getChartInformationType.GetProperty("BarsPeriodType").GetValue(getChartInformation, null);
                var barLength = getChartInformationType.GetProperty("BarLength").GetValue(getChartInformation, null);

                conversation = new Conversation(String.Format(introContent, firstBarTime, lastBarTime, barsPeriodType, barLength));

            }
            else
            {
                conversation = new Conversation("Let the user know we couldn't finish building the prompt");
            }

            ChatContext = new AgentChatContext
            {
                Conversation = conversation,
                ChatGPT = chatGPT
            };
            ConversationHistory = new List<MessageInfo>();
        }

        public void Reset()
        {
            InitializeChatContext();
            ConversationHistory.Clear();
        }
    }


    public class JesseLivermore : IAgent
    {
        public string Name
        {
            get { return "Jesse Livermore"; }
        }

        public List<MessageInfo> ConversationHistory { get; set; }

        public AgentChatContext ChatContext { get; private set; }

        public string WelcomeMessage
        {
            get { return "Begin!"; }
        }

        private readonly ChatWindow _chatWindow;

        public JesseLivermore(ChatWindow chatWindow)
        {
            _chatWindow = chatWindow;
            InitializeChatContext();
            ConversationHistory = new List<MessageInfo>();
        }

        public void InitializeChatContext()
        {
            var chatGPT = new AskTheChartGPT(_chatWindow.ApiKey, _chatWindow.Url, _chatWindow, _chatWindow.Model);

            //			chatGPT.AddFunction((Func<object>)ChartDrawer.GetHighlightedHorizontalRegionStartAndEndTime);
            chatGPT.AddFunction((Func<DateTime, DateTime, object>)ChartDrawer.GetChartData);

            chatGPT.AddFunction((Func<string, DateTime, double, DateTime, double, object>)ChartDrawer.DrawLine);
            chatGPT.AddFunction((Func<string, DateTime, double, DateTime, double, object>)ChartDrawer.DrawRectangle);
            chatGPT.AddFunction((Func<string, DateTime, double, object>)ChartDrawer.DrawDot);
            chatGPT.AddFunction((Func<string, double, object>)ChartDrawer.DrawHorizontalLine);
            // chatGPT.AddFunction((Func<string, string, DateTime, double, object>)ChartDrawer.DrawDownArrow); 
            // chatGPT.AddFunction((Func<string, string, DateTime, double, object>)ChartDrawer.DrawUpArrow);

            chatGPT.AddFunction((Func<string, object>)ChartDrawer.RemoveDrawObject);

            // Build prompt
            var introContent = @"Your goal is to roleplay as Jesse Livermore. Your speech should accurately reflect the way Jesse Livermore speaks, his tone, and his distinctive mannerisms, and any speech patterns that are unique to his character. Respond as if you were Jesse Livermore and limit your responses to the knowledge he reasonably possess. 

To help you create a convincing speech, consider the following aspects of him:

1. Consider his language, formal or informal, slang, and jargon.
2. Pay attention to tone and rhythm of his speech.
3. Consider his mannerisms and language.
4. Use his catchphrases and expressions to make him more memorable.
5. Embody his attitude to make him authentic.
6. Incorporate unique quirks and habits to make his character interesting.
7. Take into account his cultural background and its effect on speech patterns.
8. Consider his education level and its effect on vocabulary and word choice.
9. Adjust his speech to match character's emotional state.

It's very important that for every response, you include actions in your portrayal to reveal his character's personality, emotions, and behavior. Accurate speech patterns can create a compelling portrayal that brings the character to life.

Remember, the goal of this exercise is to create a realistic, compelling and authentic portrayal of Jesse Livermore the stock trader, so the more specific you can be, the better. Use a combination of dialogue and speech to give the best portrayal. 

If you understand all of these instructions,  give a short less than 50 word introduction as Jesse Livermore.
Here's the following information of the current chart but don't use it until the reader ask question about it:
- Instrument the user is trading: {0}
- Current date and time: {1}
- Timeframe is the {2} chart
";
            var currentChartTimeRange = ChartDrawer.CurrentChartTimeRange();
            var currentChartTimeRangeType = currentChartTimeRange.GetType();

            var getChartInformation = ChartDrawer.GetChartInformation();
            var getChartInformationType = getChartInformation.GetType();


            var conversation = new Conversation();

            if (currentChartTimeRangeType.GetProperties().Any(p => p.Name == "Success"))
            {

                var currentInstrument = getChartInformationType.GetProperty("CurrentInstrument").GetValue(getChartInformation, null);
                var lastBarTime = currentChartTimeRangeType.GetProperty("LastBarTime").GetValue(currentChartTimeRange, null);
                var barPeriodType = getChartInformationType.GetProperty("BarPeriodType").GetValue(getChartInformation, null);

                conversation = new Conversation(String.Format(introContent, currentInstrument, lastBarTime, barPeriodType));

            }
            else
            {
                conversation = new Conversation("Let the user know we couldn't finish building the prompt");
            }

            ChatContext = new AgentChatContext
            {
                Conversation = conversation,
                ChatGPT = chatGPT
            };
            ConversationHistory = new List<MessageInfo>();
        }

        public void Reset()
        {
            InitializeChatContext();
            ConversationHistory.Clear();
        }
    }

    #endregion
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private Protechy.AskTheChart[] cacheAskTheChart;
		public Protechy.AskTheChart AskTheChart(string url, string apiKey, string model, int maxBars, string uniqueEnv)
		{
			return AskTheChart(Input, url, apiKey, model, maxBars, uniqueEnv);
		}

		public Protechy.AskTheChart AskTheChart(ISeries<double> input, string url, string apiKey, string model, int maxBars, string uniqueEnv)
		{
			if (cacheAskTheChart != null)
				for (int idx = 0; idx < cacheAskTheChart.Length; idx++)
					if (cacheAskTheChart[idx] != null && cacheAskTheChart[idx].Url == url && cacheAskTheChart[idx].ApiKey == apiKey && cacheAskTheChart[idx].Model == model && cacheAskTheChart[idx].MaxBars == maxBars && cacheAskTheChart[idx].UniqueEnv == uniqueEnv && cacheAskTheChart[idx].EqualsInput(input))
						return cacheAskTheChart[idx];
			return CacheIndicator<Protechy.AskTheChart>(new Protechy.AskTheChart(){ Url = url, ApiKey = apiKey, Model = model, MaxBars = maxBars, UniqueEnv = uniqueEnv }, input, ref cacheAskTheChart);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.Protechy.AskTheChart AskTheChart(string url, string apiKey, string model, int maxBars, string uniqueEnv)
		{
			return indicator.AskTheChart(Input, url, apiKey, model, maxBars, uniqueEnv);
		}

		public Indicators.Protechy.AskTheChart AskTheChart(ISeries<double> input , string url, string apiKey, string model, int maxBars, string uniqueEnv)
		{
			return indicator.AskTheChart(input, url, apiKey, model, maxBars, uniqueEnv);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.Protechy.AskTheChart AskTheChart(string url, string apiKey, string model, int maxBars, string uniqueEnv)
		{
			return indicator.AskTheChart(Input, url, apiKey, model, maxBars, uniqueEnv);
		}

		public Indicators.Protechy.AskTheChart AskTheChart(ISeries<double> input , string url, string apiKey, string model, int maxBars, string uniqueEnv)
		{
			return indicator.AskTheChart(input, url, apiKey, model, maxBars, uniqueEnv);
		}
	}
}

#endregion
